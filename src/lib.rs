#![deny(clippy::correctness, clippy::suspicious)]
#![warn(clippy::complexity, clippy::perf, clippy::style, clippy::pedantic)]
#![warn(missing_docs)]

//! Implement a blanket implementation for a marker trait.
//!
//! # Basic Example
//!
//! ```
//! #[marker_trait::marker_trait]
//! pub trait AsyncTask: Send + 'static {}
//!
//! struct MySendStatic;
//! static_assertions::assert_impl_all!(MySendStatic: Send, AsyncTask);
//! ```
//!
//! Generated output:
#![cfg_attr(doctest, doc = " ````no_test")]
//! ```
//! pub trait AsyncTask: Send + 'static {}
//! impl<T: Send + 'static> AsyncTask for T {}
//! ````
//!
//! # Sealed example
//!
//! Uses the [`sealed`](https://docs.rs/sealed) crate
//!
//! ```
//! #[marker_trait::marker_trait(sealed)]
//! pub trait AsyncTask: Send + 'static {}
//!
//! struct MySendStatic;
//! // name generated by the sealed crate
//! static_assertions::assert_impl_all!(MySendStatic: Send, AsyncTask, __seal_async_task::Sealed);
//! ```
//!
//! Generated output:
#![cfg_attr(doctest, doc = " ````no_test")]
//! ```
//! #[::sealed::sealed]
//! pub trait AsyncTask: Send + 'static {}
//!
//! #[::sealed::sealed]
//! impl<T: Send + 'static> AsyncTask for T {}
//! ````

use proc_macro::TokenStream as BaseTokenStream;

use macroific::elements::{ModulePrefix, SimpleAttr};
use macroific::prelude::*;
use proc_macro2::{Delimiter, Group, Ident, Punct, Span, TokenStream};
use quote::{ToTokens, TokenStreamExt};
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;
use syn::spanned::Spanned;
use syn::{parse_macro_input, GenericParam, Generics, ItemTrait, Token, TypeParam, TypeParamBound};

/// # Options
///
/// - `#[marker_trait(sealed)]` - derive [`sealed`](https://docs.rs/sealed) on the implementation (applies it to the trait definition too)
///
/// See [crate-level docs](crate) for an example.
#[proc_macro_attribute]
pub fn marker_trait(opts_in: BaseTokenStream, input: BaseTokenStream) -> BaseTokenStream {
    let opts = {
        if opts_in.is_empty() {
            Options::default()
        } else {
            parse_macro_input!(opts_in as Options)
        }
    };

    let mut output = TokenStream::from(input.clone());
    parse_macro_input!(input as MarkerTrait).into_tokens(opts, &mut output);

    output.into()
}

#[derive(Default, AttributeOptions)]
struct Options {
    sealed: bool,
}

struct MarkerTrait {
    unsafety: Option<Token![unsafe]>,
    ident: Ident,
    generics: Generics,
    supertraits: Punctuated<TypeParamBound, Token![+]>,
}

impl MarkerTrait {
    fn into_tokens(self, Options { sealed }: Options, tokens: &mut TokenStream) {
        fn sealed_gr() -> Group {
            const SEALED: ModulePrefix = ModulePrefix::new(&["sealed", "sealed"]);

            Group::new(Delimiter::Bracket, SEALED.into_token_stream())
        }

        let Self {
            unsafety,
            ident,
            mut generics,
            supertraits,
        } = self;

        let g2 = generics.clone();
        let g2 = g2.split_for_impl().1;

        let out_ident = Ident::new("__MarkerTrait__", Span::call_site());

        generics.params.push(GenericParam::Type(TypeParam {
            attrs: Vec::new(),
            ident: out_ident.clone(),
            colon_token: None,
            bounds: supertraits,
            eq_token: None,
            default: None,
        }));

        if sealed {
            let new_tokens = std::mem::replace(tokens, {
                let mut out = TokenStream::new();
                out.append(Punct::new_joint('#'));
                out.append(sealed_gr());
                out
            });
            tokens.extend(new_tokens);

            tokens.append(Punct::new_joint('#'));
            tokens.append(sealed_gr());
        }

        SimpleAttr::AUTO_DERIVED.to_tokens(tokens);
        unsafety.to_tokens(tokens);

        let (g1, _, g3) = generics.split_for_impl();
        tokens.append(Ident::create("impl"));
        g1.to_tokens(tokens);
        tokens.append(ident);
        g2.to_tokens(tokens);
        tokens.append(Ident::create("for"));
        tokens.append(out_ident);
        g3.to_tokens(tokens);

        tokens.append(Group::new(Delimiter::Brace, TokenStream::new()));
    }
}

impl Parse for MarkerTrait {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let trait_def = input.parse::<ItemTrait>()?;
        if let Some(token) = trait_def.auto_token {
            return Err(syn::Error::new_spanned(token, "auto trait is not allowed"));
        }

        let mut items = trait_def.items.into_iter();
        if let Some(first) = items.next() {
            let mut span = first.span();
            for next in items {
                if let Some(joined) = span.join(next.span()) {
                    span = joined;
                } else {
                    return Err(syn::Error::new_spanned(
                        next,
                        "Trait item contents' tokens somehow point to different files",
                    ));
                }
            }
        }

        Ok(Self {
            unsafety: trait_def.unsafety,
            ident: trait_def.ident,
            generics: trait_def.generics,
            supertraits: trait_def.supertraits,
        })
    }
}

impl Parse for Options {
    #[inline]
    fn parse(input: ParseStream) -> syn::Result<Self> {
        AttributeOptions::from_stream(input)
    }
}
